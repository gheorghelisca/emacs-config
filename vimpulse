
(require 'highlight-regexp)

; Some additional vim commands
(defvar viper-private-ex-commands '( ("noh" (viper-isearch-clear))
                                     ("grep" (viper-grep))
                                     ("Q" (save-buffers-kill-emacs)) ))
(setq ex-token-alist (append viper-private-ex-commands ex-token-alist))

; Search variables 
(defvar viper-isearch-forward t)
(defvar viper-search-method 'isearch)

; make :n cycle through buffers on the current window
(setq ex-cycle-other-window nil)

; Redefined keys
; search keys
(define-key viper-vi-global-user-map "/" (lambda () 
                                           (interactive)
                                           (viper-isearcher 'forward)))
(define-key viper-vi-global-user-map "?" (lambda () 
                                           (interactive)
                                           (viper-isearcher 'backward)))
; Window keys
(define-key viper-vi-global-user-map "H" 'windmove-left)
(define-key viper-vi-global-user-map "J" 'windmove-down)
(define-key viper-vi-global-user-map "K" 'windmove-up)
(define-key viper-vi-global-user-map "L" 'windmove-right)
(define-key viper-vi-global-user-map "\C-w>" 'enlarge-window-horizontally)
(define-key viper-vi-global-user-map "\C-w<" 'shrink-window-horizontally)
(define-key viper-vi-global-user-map "\C-w+" 'enlarge-window)
(define-key viper-vi-global-user-map "\C-w-" 'shrink-window)
(define-key viper-vi-global-user-map [f5] (lambda ()
                                            (interactive)
                                            (compile "make")))

; ECB
(define-key viper-vi-global-user-map "\C-w\C-t" 'viper-ecb-toggle)

(defvar viper-ecb-active nil)

(defun viper-ecb-toggle ()
  (interactive)
  (cond ( viper-ecb-active
          (ecb-deactivate)
          (setq viper-ecb-active nil) )
        ( t
          (ecb-activate)
          (setq viper-ecb-active t) )))
    
; Isearch
(defun viper-isearcher (direction &optional pattern)
  (interactive)
  (highlight-regexp-clear)
  (setq viper-isearch-forward (eq direction 'forward))
  (setq viper-search-method 'isearch)
  (if (eq direction 'forward)
    (isearch-forward-regexp)
    (isearch-backward-regexp))
  (when (not (equal isearch-string ""))
    (progn
      (setq viper-s-string isearch-string)
      (setq viper-s-forward (if (eq direction 'forward) t nil))
      (highlight-regexp-regexp isearch-string))))

(defun viper-isearch-clear ()
  (interactive)
  (highlight-regexp-clear)
  (when (eq viper-search-method 'isearch)
    (isearch-exit)))

(defun viper-search-for-symbol-at-point (whether-forward)
  "Search forwards or backwards for the symbol under point."
  (setq viper-search-method nil)
  (let ((symbol (concat "\\<" (thing-at-point 'symbol) "\\>")))
    (setq viper-s-string symbol)
    (setq viper-s-forward whether-forward)
    (highlight-regexp-clear)
    (highlight-regexp-regexp symbol)
    (viper-search symbol whether-forward 1)))

(defun viper-grep (&optional grep-string)
  (unless grep-string
    (setq grep-string (concat "grep " (read-string ":grep "))))
    (grep grep-string)
    (viper-mode))

;;; Manipulation of Vipers functions by using the advice feature
;;; Many of the functions here rely as heavily on Viper's internals as Viper itself
(require 'advice)

; Function to make brace highlighting like Vim's
; Contributed by Alessandro Piras
(defadvice show-paren-function (around viper-shop-paren-function activate)
  (if viper-vi-basic-minor-mode
      (cond
       ((= (char-after (point)) ?\))
    (forward-char)
    ad-do-it
    (backward-char))
       ((= (char-after (- (point) 1)) ?\)) nil)
       (t ad-do-it))
    ad-do-it))

